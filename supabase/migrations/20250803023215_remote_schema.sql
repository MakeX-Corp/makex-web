create extension if not exists "moddatetime" with schema "public" version '1.0';

create extension if not exists "vector" with schema "public" version '0.8.0';

create type "public"."app_status" as enum ('bundling', 'changing', 'active', 'starting', 'paused', 'pausing', 'success', 'deleted');

create type "public"."deployment" as enum ('web', 'eas-update', 'freestyle');

create type "public"."deployment_status" as enum ('failed', 'completed', 'uploading');

create type "public"."expo_status" as enum ('starting', 'bundling', 'bundled');

create type "public"."sandbox_provider" as enum ('e2b', 'daytona');

create type "public"."sandbox_status" as enum ('active', 'deleted', 'starting', 'paused', 'resuming', 'pausing', 'temporary');

create table "public"."app_chat_history" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "app_id" uuid not null,
    "user_id" uuid not null,
    "content" text not null,
    "role" text not null,
    "model_used" text,
    "metadata" jsonb,
    "input_tokens_used" integer,
    "output_tokens_used" integer,
    "created_at" timestamp without time zone not null default now(),
    "cost" numeric(10,4),
    "session_id" uuid,
    "commit_hash" text default 'NULL'::text,
    "message_id" text,
    "parts" jsonb,
    "plain_text" text
);


alter table "public"."app_chat_history" enable row level security;

create table "public"."chat_sessions" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "app_id" uuid not null,
    "user_id" uuid not null,
    "title" text,
    "metadata" jsonb,
    "created_at" timestamp without time zone not null default now(),
    "visible" boolean default true
);


alter table "public"."chat_sessions" enable row level security;

create table "public"."embeddings" (
    "id" uuid not null default gen_random_uuid(),
    "content" text not null,
    "embedding" vector(1536) not null,
    "source" text,
    "category" text,
    "created_at" timestamp with time zone default now()
);


alter table "public"."embeddings" enable row level security;

create table "public"."mobile_subscriptions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "subscription_type" text,
    "subscription_status" text,
    "subscription_start" timestamp with time zone,
    "subscription_end" timestamp with time zone,
    "messages_used_this_period" bigint,
    "user_id" uuid default gen_random_uuid(),
    "last_transaction_id" character varying
);


alter table "public"."mobile_subscriptions" enable row level security;

create table "public"."subscriptions" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "status" text,
    "price_id" text,
    "quantity" integer default 1,
    "cancel_at_period_end" boolean default false,
    "canceled_at" timestamp without time zone,
    "current_period_start" timestamp without time zone,
    "current_period_end" timestamp without time zone,
    "created_at" timestamp without time zone default now(),
    "customer_id" text,
    "subscription_id" text,
    "messages_used_this_period" bigint,
    "subscription_type" text
);


alter table "public"."subscriptions" enable row level security;

create table "public"."url_mappings" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "app_id" uuid,
    "share_url" text,
    "web_url" text,
    "app_url" text,
    "dub_id" text,
    "updated_at" timestamp with time zone,
    "dub_key" text,
    "share_id" text default gen_random_uuid()
);


alter table "public"."url_mappings" enable row level security;

create table "public"."user_apps" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "user_id" uuid not null,
    "app_name" text not null,
    "app_url" text,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "status" text,
    "initial_commit" text,
    "api_url" text,
    "display_name" text,
    "convex_prod_url" text,
    "convex_project_id" text,
    "convex_dev_url" text,
    "git_repo_id" text,
    "convex_dev_admin_key" text,
    "convex_prod_admin_key" text,
    "github_sync_repo" text,
    "sandbox_id" text,
    "sandbox_status" text
);


alter table "public"."user_apps" enable row level security;

create table "public"."user_deployments" (
    "created_at" timestamp with time zone not null default now(),
    "app_id" uuid,
    "user_id" uuid,
    "status" deployment_status,
    "id" uuid not null default gen_random_uuid(),
    "app_url" text,
    "type" deployment,
    "metadata" jsonb,
    "web_url" text,
    "deployment_id" text
);


alter table "public"."user_deployments" enable row level security;

create table "public"."user_devices" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "device_token" text not null,
    "user_id" uuid default gen_random_uuid(),
    "last_used_at" timestamp with time zone
);


alter table "public"."user_devices" enable row level security;

create table "public"."user_sandboxes" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "sandbox_id" text,
    "sandbox_created_at" timestamp with time zone default now(),
    "sandbox_updated_at" timestamp with time zone default now(),
    "sandbox_status" sandbox_status not null,
    "app_id" uuid not null,
    "api_url" text,
    "app_url" text,
    "app_status" app_status,
    "sandbox_provider" sandbox_provider default 'e2b'::sandbox_provider,
    "expo_status" expo_status
);


alter table "public"."user_sandboxes" enable row level security;

CREATE UNIQUE INDEX app_chat_history_pkey ON public.app_chat_history USING btree (id);

CREATE UNIQUE INDEX chat_sessions_pkey ON public.chat_sessions USING btree (id);

CREATE UNIQUE INDEX embeddings_pkey ON public.embeddings USING btree (id);

CREATE INDEX idx_app_chat_history_app_id ON public.app_chat_history USING btree (app_id);

CREATE INDEX idx_app_chat_history_user_id ON public.app_chat_history USING btree (user_id);

CREATE INDEX idx_chat_sessions_app_id ON public.chat_sessions USING btree (app_id);

CREATE INDEX idx_chat_sessions_user_id ON public.chat_sessions USING btree (user_id);

CREATE INDEX idx_user_apps_user_id ON public.user_apps USING btree (user_id);

CREATE UNIQUE INDEX mobile_subscriptions_pkey ON public.mobile_subscriptions USING btree (id);

CREATE UNIQUE INDEX mobile_subscriptions_user_id_key ON public.mobile_subscriptions USING btree (user_id);

CREATE UNIQUE INDEX subscriptions_pkey ON public.subscriptions USING btree (id);

CREATE UNIQUE INDEX subscriptions_user_id_key ON public.subscriptions USING btree (user_id);

CREATE UNIQUE INDEX url_mappings_pkey ON public.url_mappings USING btree (id);

CREATE UNIQUE INDEX url_mappings_share_id_key ON public.url_mappings USING btree (share_id);

CREATE UNIQUE INDEX user_apps_pkey ON public.user_apps USING btree (id);

CREATE UNIQUE INDEX user_deployments_pkey ON public.user_deployments USING btree (id);

CREATE UNIQUE INDEX user_devices_device_token_key ON public.user_devices USING btree (device_token);

CREATE UNIQUE INDEX user_devices_pkey ON public.user_devices USING btree (id);

CREATE INDEX user_sandboxes_app_id_idx ON public.user_sandboxes USING btree (app_id);

CREATE UNIQUE INDEX user_sandboxes_pkey ON public.user_sandboxes USING btree (id);

alter table "public"."app_chat_history" add constraint "app_chat_history_pkey" PRIMARY KEY using index "app_chat_history_pkey";

alter table "public"."chat_sessions" add constraint "chat_sessions_pkey" PRIMARY KEY using index "chat_sessions_pkey";

alter table "public"."embeddings" add constraint "embeddings_pkey" PRIMARY KEY using index "embeddings_pkey";

alter table "public"."mobile_subscriptions" add constraint "mobile_subscriptions_pkey" PRIMARY KEY using index "mobile_subscriptions_pkey";

alter table "public"."subscriptions" add constraint "subscriptions_pkey" PRIMARY KEY using index "subscriptions_pkey";

alter table "public"."url_mappings" add constraint "url_mappings_pkey" PRIMARY KEY using index "url_mappings_pkey";

alter table "public"."user_apps" add constraint "user_apps_pkey" PRIMARY KEY using index "user_apps_pkey";

alter table "public"."user_deployments" add constraint "user_deployments_pkey" PRIMARY KEY using index "user_deployments_pkey";

alter table "public"."user_devices" add constraint "user_devices_pkey" PRIMARY KEY using index "user_devices_pkey";

alter table "public"."user_sandboxes" add constraint "user_sandboxes_pkey" PRIMARY KEY using index "user_sandboxes_pkey";

alter table "public"."app_chat_history" add constraint "app_chat_history_app_id_fkey" FOREIGN KEY (app_id) REFERENCES user_apps(id) ON DELETE CASCADE not valid;

alter table "public"."app_chat_history" validate constraint "app_chat_history_app_id_fkey";

alter table "public"."app_chat_history" add constraint "app_chat_history_session_id_fkey" FOREIGN KEY (session_id) REFERENCES chat_sessions(id) not valid;

alter table "public"."app_chat_history" validate constraint "app_chat_history_session_id_fkey";

alter table "public"."app_chat_history" add constraint "app_chat_history_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."app_chat_history" validate constraint "app_chat_history_user_id_fkey";

alter table "public"."chat_sessions" add constraint "chat_sessions_app_id_fkey" FOREIGN KEY (app_id) REFERENCES user_apps(id) not valid;

alter table "public"."chat_sessions" validate constraint "chat_sessions_app_id_fkey";

alter table "public"."chat_sessions" add constraint "chat_sessions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."chat_sessions" validate constraint "chat_sessions_user_id_fkey";

alter table "public"."mobile_subscriptions" add constraint "mobile_subscriptions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."mobile_subscriptions" validate constraint "mobile_subscriptions_user_id_fkey";

alter table "public"."mobile_subscriptions" add constraint "mobile_subscriptions_user_id_key" UNIQUE using index "mobile_subscriptions_user_id_key";

alter table "public"."subscriptions" add constraint "subscriptions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_user_id_fkey";

alter table "public"."subscriptions" add constraint "subscriptions_user_id_key" UNIQUE using index "subscriptions_user_id_key";

alter table "public"."url_mappings" add constraint "url_mappings_app_id_fkey" FOREIGN KEY (app_id) REFERENCES user_apps(id) not valid;

alter table "public"."url_mappings" validate constraint "url_mappings_app_id_fkey";

alter table "public"."url_mappings" add constraint "url_mappings_share_id_key" UNIQUE using index "url_mappings_share_id_key";

alter table "public"."user_apps" add constraint "user_apps_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_apps" validate constraint "user_apps_user_id_fkey";

alter table "public"."user_deployments" add constraint "user_deployments_app_id_fkey" FOREIGN KEY (app_id) REFERENCES user_apps(id) not valid;

alter table "public"."user_deployments" validate constraint "user_deployments_app_id_fkey";

alter table "public"."user_deployments" add constraint "user_deployments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."user_deployments" validate constraint "user_deployments_user_id_fkey";

alter table "public"."user_devices" add constraint "user_devices_device_token_key" UNIQUE using index "user_devices_device_token_key";

alter table "public"."user_devices" add constraint "user_devices_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."user_devices" validate constraint "user_devices_user_id_fkey";

alter table "public"."user_sandboxes" add constraint "user_sandboxes_app_id_fkey" FOREIGN KEY (app_id) REFERENCES user_apps(id) ON DELETE CASCADE not valid;

alter table "public"."user_sandboxes" validate constraint "user_sandboxes_app_id_fkey";

alter table "public"."user_sandboxes" add constraint "user_sandboxes_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_sandboxes" validate constraint "user_sandboxes_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.match_embeddings(query_embedding vector, match_threshold double precision, match_count integer)
 RETURNS TABLE(content text, source text, category text, similarity double precision)
 LANGUAGE sql
 STABLE
AS $function$
  select
    content,
    source,
    category,
    1 - (embedding <=> query_embedding) as similarity
  from embeddings
  where embedding <=> query_embedding < 1 - match_threshold
  order by embedding <=> query_embedding
  limit match_count;
$function$
;

CREATE OR REPLACE FUNCTION public.match_embeddings(query_embedding vector, match_threshold double precision, match_count integer, category_filter text)
 RETURNS TABLE(content text, source text, category text, similarity double precision)
 LANGUAGE sql
AS $function$
  SELECT
    content,
    source,
    category,
    1 - (embedding <=> query_embedding) AS similarity
  FROM embeddings
  WHERE (category = category_filter OR category_filter IS NULL)
    AND embedding <=> query_embedding < 1 - match_threshold
  ORDER BY embedding <=> query_embedding
  LIMIT match_count;
$function$
;

CREATE OR REPLACE FUNCTION public.update_sandbox_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.sandbox_updated_at = now();
  return new;
end;
$function$
;

create policy "No deletes allowed"
on "public"."app_chat_history"
as permissive
for delete
to public
using (false);


create policy "No updates allowed"
on "public"."app_chat_history"
as permissive
for update
to public
using (false);


create policy "Users can insert their own chat messages"
on "public"."app_chat_history"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can read their own chat history"
on "public"."app_chat_history"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "No one can delete sessions"
on "public"."chat_sessions"
as permissive
for delete
to public
using (false);


create policy "Users can insert their own sessions"
on "public"."chat_sessions"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can read their own sessions"
on "public"."chat_sessions"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Users can update their own sessions"
on "public"."chat_sessions"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Admin insert"
on "public"."mobile_subscriptions"
as permissive
for insert
to public
with check ((auth.role() = 'admin'::text));


create policy "Users can view their own subscriptions"
on "public"."mobile_subscriptions"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Admin insert"
on "public"."subscriptions"
as permissive
for insert
to public
with check ((auth.role() = 'admin'::text));


create policy "Users can view their own subscriptions"
on "public"."subscriptions"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Admins only can do anything"
on "public"."url_mappings"
as permissive
for all
to public
using (((auth.role() = 'authenticated'::text) AND ((auth.jwt() ->> 'role'::text) = 'admin'::text)))
with check (((auth.role() = 'authenticated'::text) AND ((auth.jwt() ->> 'role'::text) = 'admin'::text)));


create policy "Admins can do everything"
on "public"."user_apps"
as permissive
for all
to public
using (((auth.jwt() ->> 'role'::text) = 'ADMIN'::text))
with check (((auth.jwt() ->> 'role'::text) = 'ADMIN'::text));


create policy "No one can delete apps"
on "public"."user_apps"
as permissive
for delete
to public
using (false);


create policy "Users can insert their own apps"
on "public"."user_apps"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can update their own apps"
on "public"."user_apps"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Users can view their own apps"
on "public"."user_apps"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Admin"
on "public"."user_deployments"
as permissive
for all
to public
using (((auth.jwt() ->> 'role'::text) = 'ADMIN'::text))
with check (((auth.jwt() ->> 'role'::text) = 'ADMIN'::text));


create policy "User can insert their own deployment"
on "public"."user_deployments"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can read their own deployments"
on "public"."user_deployments"
as permissive
for select
to public
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can update their own deployments"
on "public"."user_deployments"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Users can create their own devices"
on "public"."user_devices"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can read their own devices"
on "public"."user_devices"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Users can update their own devices"
on "public"."user_devices"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Admins can do everything"
on "public"."user_sandboxes"
as permissive
for all
to public
using (((auth.jwt() ->> 'role'::text) = 'ADMIN'::text))
with check (((auth.jwt() ->> 'role'::text) = 'ADMIN'::text));


create policy "Enable users to view their own data only"
on "public"."user_sandboxes"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.user_apps FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER set_sandbox_updated_at BEFORE UPDATE ON public.user_sandboxes FOR EACH ROW EXECUTE FUNCTION update_sandbox_updated_at();


